# -*- coding: utf-8 -*-
"""Cópia de CálculoNumérico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M2_kcS0Zo-ABEnVj-CC-Mu2dgsJ4FgcZ
"""

# Instalando bibliotecas
import matplotlib.pyplot as plt
# Pedindo atribuições para os valores de x e de y
x=list(map(int, input("elementos de x: ").strip().split()))
y=list(map(int, input("elementos de y: ").strip().split()))
#plotando gráfico
#plotando pontos no gráfico
plt.plot(x,y,'*', color='red')
#plotando linha no gráfico
plt.plot(x,y,color="orange",linewidth=1.0)
# plotando título do grafico e dos eixos x e y
plt.title("Tentando imitar um sistema exponencial", color="blue")
plt.xlabel("Eixo x", color="green")
plt.ylabel("Eixo y", color="purple")
# plotando linhas de grade
plt.grid()
plt.show()

# Instalando bibliotecas
import numpy as np
import matplotlib.pyplot as plt
# cria dominio com valores de t
t=np.arange(0,4.05,0.01)
# define y(t)
y=np.exp(-t)*(np.cos(10*t)+np.sin(10*t))
# plotando o grafico
plt.plot(t,y,color="orange",linewidth=2.0)
# plotando título do grafico e dos eixos x e y
plt.title("Gráfico do Sistema Massa Mola", color="blue")
plt.xlabel("Valores de t", color="green")
plt.ylabel("Altura da Mola", color="purple")
# plotando linhas de grade
plt.grid()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
# define que o grafico sera 3D
fig = plt.figure()
ax = plt.axes(projection='3d')
# define funcao de 2 variaveis
def f(x, y): return np.sin(x)+np.cos(y)
# define dominio
x = np.linspace(-6, 6, 300)
y = np.linspace(-6, 6, 300)
# cria a malha (x,y)
X, Y = np.meshgrid(x, y)
Z = f(X, Y)
# faz o grafico 3D
ax = plt.axes(projection='3d')
ax.plot_wireframe(X, Y, Z, color='orange')
ax.set_title('Grafico de f(x,y)');
plt.show()

import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 2 * np.pi, 200)
y = np.sin(x)

fig, ax = plt.subplots()
ax.set_title('Função Seno em ação');
plt.xlabel("Valores de x", color="green")
plt.ylabel("Valores de y", color="purple")
ax.plot(x, y)
plt.grid()
plt.show()

# Sample code for generation of first example
import numpy as np
# from matplotlib import pyplot as plt
import matplotlib.pyplot as plt
# pyplot imported for plotting graphs

x = np.linspace(-4, 4, 9)

# numpy.linspace creates an array of
# 9 linearly placed elements between
# -4 and 4, both inclusive
y = np.linspace(-5, 5, 11)

# The meshgrid function returns
# two 2-dimensional arrays
x_1, y_1 = np.meshgrid(x, y)

print("x_1 = ")
print(x_1)
print("y_1 = ")
print(y_1)

import numpy as np
import matplotlib.pyplot as plt

# criando os dados
x, y = np.meshgrid(np.linspace(-2, 2, 10), np.linspace(-2, 2, 10))
Ex = -2*x/np.sqrt(x**2 + y**2+1e-8) # componente x do campo elétrico
Ey = -2*y/np.sqrt(x**2 + y**2+1e-8) # componente y do campo elétrico

# plotando o gráfico
fig, ax = plt.subplots()
intensidade = np.sqrt(Ex**2 + Ey**2) # calculando a intensidade do vetor
ax.quiver(x, y, Ex, Ey, intensidade, cmap='coolwarm')
ax.set_xlabel('x')
ax.set_ylabel('y')
plt.show()

"""Neste código, a função quiver é utilizada para plotar os vetores. Ela recebe como parâmetros as coordenadas x e y dos pontos em que os vetores devem ser plotados, as componentes E_x e E_y do campo elétrico em cada ponto, e a intensidade do vetor. A opção cmap é utilizada para escolher o mapa de cores que será utilizado para indicar a intensidade dos vetores. No caso do exemplo, foi escolhido o mapa de cores coolwarm.

A intensidade do vetor é calculada utilizando a fórmula intensidade = np.sqrt(Ex**2 + Ey**2), que corresponde à magnitude do vetor. Essa magnitude é utilizada como tamanho do vetor plotado pela função quiver.

É importante notar que adicionei um pequeno valor 1e-8 no denominador do cálculo de Ex e Ey para evitar a divisão por zero, o que causaria um erro.

Espero que isso ajude a entender melhor a utilização da função quiver em conjunto com o NumPy e o Matplotlib!
"""

import numpy as np
import matplotlib.pyplot as plt

# Definindo os parâmetros da simulação
T0 = 373    # temperatura inicial do objeto em K
Tamb = 293  # temperatura ambiente em K
k = 0.1     # constante de proporcionalidade em 1/s
dt = 0.1    # intervalo de tempo em segundos
tmax = 100  # tempo máximo de simulação em segundos

# Definindo a função que descreve a equação diferencial
def newton_cooling(T, t):
    dTdt = -k*(T - Tamb)
    return dTdt

# Utilizando o método de Euler para solucionar a equação diferencial
t = np.arange(0, tmax, dt)
T = np.zeros_like(t)
T[0] = T0
for i in range(len(t)-1):
    dTdt = newton_cooling(T[i], t[i])
    T[i+1] = T[i] + dTdt*dt

# Plotando o gráfico da temperatura em função do tempo
plt.plot(t, T)
plt.xlabel('Tempo (s)')
plt.ylabel('Temperatura (K)')
plt.title('Resfriamento de um objeto')
plt.grid()
plt.show()

import numpy as np

# Define os parâmetros do problema
Tamb = 293.0    # Temperatura ambiente em Kelvin
Ti = 373.0      # Temperatura inicial do objeto em Kelvin
k = 0.1         # Constante de resfriamento
tmax = 1000.0   # Tempo total de simulação em segundos
dt = 1.0        # Passo de tempo em segundos

# Inicializa o vetor de tempo e temperatura
t = np.arange(0, tmax+dt, dt)
y = np.zeros_like(t)
y[0] = Ti

# Usa o método de Euler para calcular a temperatura em cada passo de tempo
for i in range(1, len(t)):
    y[i] = y[i-1] + dt * (-k*(y[i-1] - Tamb))

# Plota o gráfico da temperatura em função do tempo
import matplotlib.pyplot as plt
plt.plot(t, y)
plt.xlabel('Tempo (s)')
plt.ylabel('Temperatura (K)')
plt.show()

"""dy/dt = -k*(y - Tamb)

Onde y é a temperatura do objeto em Kelvin, t é o tempo em segundos, Tamb é a temperatura ambiente em Kelvin e k é a constante de resfriamento.

Para resolver esta EDO, utilizamos o método de Euler, que é um método numérico simples para resolver equações diferenciais. A ideia básica do método de Euler é aproximar a solução da equação diferencial por meio de uma sequência de retas tangentes à curva da solução.

O método de Euler envolve o seguinte procedimento:

Inicialize a temperatura inicial y0.

Defina um passo de tempo Δt.

Calcule a temperatura em um tempo futuro t = t0 + Δt usando a seguinte equação:

y1 = y0 + Δt * (-k*(y0 - Tamb))

onde y1 é a temperatura no tempo t = t0 + Δt.

Repita o passo 3 para calcular a temperatura em tempos futuros, atualizando y0 com o valor mais recente de y1.

Neste código, usamos a função numpy.arange para criar um vetor de tempo t com intervalos de dt segundos. O vetor y é inicializado com a temperatura inicial Ti. Em seguida, usamos um loop para calcular a temperatura em cada passo de tempo usando o método de Euler. Por fim, plotamos o gráfico da temperatura em função do tempo usando a biblioteca Matplotlib.
"""

import numpy as np
import matplotlib.pyplot as plt

# Criando um campo elétrico rotacional de exemplo
x = np.linspace(-2, 2, 10)
y = np.linspace(-2, 2, 10)
X, Y = np.meshgrid(x, y)
E_x = Y
E_y = -X

# Criando um gráfico de vetor para representar o campo elétrico
plt.quiver(X, Y, E_x, E_y)
plt.title('Campo elétrico rotacional')
plt.xlabel('Eixo x')
plt.ylabel('Eixo y')
plt.show()

"""De acordo com as equações de Maxwell, o rotacional do campo elétrico é dado pela seguinte expressão:

∇ x E = - ∂B/∂t

onde ∇ é o operador nabla, E é o campo elétrico e B é o campo magnético. Essa equação mostra que a variação temporal do campo magnético é responsável pela existência de um rotacional no campo elétrico.

No caso específico em que o campo elétrico é dado por E_x = Y e E_y = -x, é possível calcular o rotacional usando a definição matemática do operador nabla e as propriedades de derivadas parciais. O resultado é:

∇ x E = ( ∂E_y/∂x - ∂E_x/∂y ) i + ( ∂E_x/∂x + ∂E_y/∂y ) j
= 2 i + 2 j

O resultado obtido é um vetor constante na direção diagonal, indicando que o campo elétrico é rotacional e tem um módulo constante. Isso pode ser verificado visualmente no gráfico de vetores, em que as setas formam círculos centrados na origem.

É importante ressaltar que a interpretação física do rotacional do campo elétrico depende do contexto em que ele está inserido. Em geral, o rotacional está relacionado com a presença de fontes ou correntes elétricas, que produzem variações temporais no campo magnético. Em outras palavras, o rotacional do campo elétrico é uma consequência da lei de Faraday da indução eletromagnética, que relaciona as variações temporais do campo magnético com a geração de um campo elétrico.

Referências:

Griffiths, D. J. (2017). Introduction to electrodynamics (4th ed.). Cambridge University Press.
Reitz, J. R., Milford, F. J., & Christy, R. W. (1993). Foundations of electromagnetic theory (4th ed.). Addison-Wesley.
"""

import numpy as np
import matplotlib.pyplot as plt

# Definindo a função a ser integrada
def f(x):
    return x**2

# Definindo os limites de integração
a, b = -2, 4

# Definindo a quantidade de pontos de amostragem
N = 1000

# Gerando os pontos de amostragem
x = np.linspace(a, b, N)
y = f(x)

# Integrando a função usando a regra do trapézio
integral = np.trapz(y, x)

# Plotando o gráfico da função e da integral
fig, ax = plt.subplots()
ax.plot(x, y, label='Função x^2')
ax.fill_between(x, y, 0, alpha=0.2)
ax.axhline(color='black', linewidth=0.5)
ax.axvline(color='black', linewidth=0.5)
ax.text(0.5*(a+b), 0.8*max(y), 'Integral = {:.2f}'.format(integral))
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('Integral da função x^2')
ax.legend()
plt.show()

import numpy as np
from scipy.integrate import simps
import matplotlib.pyplot as plt

# Definindo a função a ser integrada
def f(x):
    return x**2

# Definindo os limites de integração
a, b = -2, 4

# Gerando os pontos para o gráfico
x = np.linspace(a, b, 100)
y = f(x)

# Calculando a integral usando a função simps
integral = simps(y, x)

# Plotando o gráfico com a área sombreada representando a integral
fig, ax = plt.subplots()
ax.plot(x, y, 'b', linewidth=2)
ax.fill_between(x, y, 0, where=(x >= a) & (x <= b), facecolor='gray', alpha=0.5)
ax.text(0.5*(a+b), 0.5*f(0), 'Integral = {}'.format(integral), fontsize=12, ha='center')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('Integral de x^2 de {} a {}'.format(a, b))
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Definindo a função f(x) = x^2
def f(x):
    return x**2

# Definindo os pontos de x para calcular a derivada
x = np.linspace(-5, 5, 1000)

# Calculando a derivada de f(x)
dfdx = np.diff(f(x))/np.diff(x)

# Plotando o gráfico da derivada
plt.plot(x[:-1], dfdx, label='Derivada de f(x)')
plt.legend()
plt.title('Gráfico da Derivada de f(x) = x^2')
plt.xlabel('x')
plt.ylabel('f\'(x)')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# valores de corrente e tensão
I = np.array \
([0.0234, 0.047, 0.072, 0.098, 0.122, 0.150, 0.170, 0.195, 0.230, 0.260])  # corrente em A
V = np.array([2, 4, 6 , 8 , 10, 12, 14, 16, 18, 20])  # tensão em V

# cálculo da resistência R
R = np.sum(I * V) / np.sum(I ** 2)

# plot do gráfico
plt.plot(I, V, 'o', label='Dados experimentais')
plt.plot(I, R*I, '-', label='Ajuste linear')
plt.xlabel('Corrente (A)')
plt.ylabel('Tensão (V)')
plt.title(f'Reta R = {R:.2f}')
plt.legend()
plt.grid
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Valores de tensão e corrente experimentais
V = np.array([1.7, 1.8, 1.9, 2.0, 2.1, 2.2])
i = np.array([0.00008, 0.001, 0.00468, 0.01071, 0.01893, 0.0273])

# Cálculo da resistência experimental
R = V / i

# Plotagem da curva conectando os pontos experimentais
plt.plot(i, R, '-o')
plt.xlabel('Corrente (A)')
plt.ylabel('Resistência (Ω)')
plt.title('Comportamento da resistência')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Valores de tensão e corrente
V = np.array([1.7, 1.8, 1.9, 2.0, 2.1, 2.2])
I = np.array([0.00008, 0.001, 0.00468, 0.01071, 0.01893, 0.0273])

# Cálculo da resistência
R = np.sum(I * V) / np.sum(I ** 2)

# Plotagem do gráfico
fig, ax = plt.subplots()
ax.plot(I, V, '-o')
ax.set_xlabel('Corrente (A)')
ax.set_ylabel('Tensão (V)')
ax.set_title(f'Comportamento da Resistência: R = {R:.2f} Ω')
plt.show()

"""Aparentemente, método errado para cálculo da resistência em plotar o seu gráfico

"""

import numpy as np
import matplotlib.pyplot as plt

# Definindo os valores de x, y e z para o sistema linear
x = np.array([3, -4, 2])
y = np.array([-2, 7, -3])
z = np.array([-1, -1, 1])

# Definindo os resultados das equações
B = np.array([12, 0, 0])

# Definindo a matriz A
A = np.array([[x[0], y[0], z[0]],
              [x[1], y[1], z[1]],
              [x[2], y[2], z[2]]])

# Utilizando o método da linalg.inv(A) para encontrar as soluções
X = np.linalg.inv(A).dot(B)

# Imprimindo as soluções
print("x = ", X[0])
print("y = ", X[1])
print("z = ", X[2])

# Plotando um gráfico com as soluções
fig = plt.figure()
ax = fig.add_subplot(projection='3d')
ax.scatter(X[0], X[1], X[2], c='r', marker='o')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
plt.grid()
plt.show()

#gráfico de um ponto kkkkkkkkk

"""O programa acima define os valores de x, y e z para o sistema linear, bem como os resultados das equações em B. Em seguida, ele define a matriz A e utiliza o método da linalg.inv(A) para encontrar as soluções para as equações. Por fim, ele imprime as soluções e plota um gráfico 3D com as soluções encontradas."""

num_dec1 = 0.3
num_dec2 = 0.1

print("Número Decimal: %.17f" %num_dec1)
print("Número Decimal: %.17f" %num_dec2)

#Verificar que existem limites na representação de valores reais na linguagem de programação de Python
print(1.7e308)
print(1.82e308)

#O programa em Python fornece o número de bits necessários para armazenar um número inteiro no computador
#Entrando com um número
num = int(input("Entre com um número inteiro: "))
#Total de bits para representar um número inteiro
bits = num.bit_length()
print("Bits requeridos para armazenar o número",num,"=",bits)
print("O valor binário do número",num,"é",bin(num))

x4 = (1*2**-1)
x3 = (0*2**-2)
x2 = (1*2**-3)
x1 = (1*2**-4)
x = x1+x2+x3+x4
print(x)

"""Programa para converter um número inteiro de base 10 em binário passo-a-passo:

1- Receber um valor (na base decimal) e armazená-lo em uma variável, chamada "dividendo"

2- Armazenar o valor de dividendo, em outra variável, chamada "numero_digitado"

3- Criar uma variável, chamada "Quociente" e armazenar o valor "1"

4- Criar um while com condição de verificação com "Quociente" >= 1

*   Criar uma variável, chamada "resto", para receber o módulo do "dividendo" por 2 (operador %)
*   Inserir o resultado do "resto" na lista vazia - Obs: a cada nova iteração, o resultado armazenado aqui, deve ser colocado na primeira posição da lista (posição 0)
*   A variável "Quociente" deve receber o valor da divisão inteira do "dividendo" por 2 (operador //)
*   A variável "dividendo" deve receber o valor do "quociente"
*   Criar uma variável, chamada "binario" que irá unir (join) todos os itens armazenados na lista, porém, antes disso, convertendo-os para strings (str)
*   Imprimir o resultado armazenado em "binario"

"""

#Convertendo Decimal em Binário
dividendo = int(input("Digite um número (Base decimal) para ser convertido em Binário: "))
numero_digitado = dividendo
quociente = 1
lista = []

while quociente >= 1:
  resto = dividendo%2
  lista.insert (0,resto)
  quociente = dividendo // 2
  dividendo = quociente

binario = "".join([str(item) for item in lista])
print("O número", numero_digitado,", quando convertido em binário, vale:", binario)

def fracao_para_binario(frac):
    # separa o numerador e o denominador da fração
    numerador, denominador = frac.as_integer_ratio()
    # converte o numerador para binário
    numerador_binario = bin(numerador)[2:]
    # calcula o número de bits necessários para representar o denominador em binário
    num_bits = len(bin(denominador)[2:])
    # completa o numerador binário com zeros à esquerda para ter o mesmo número de bits do denominador
    numerador_binario_completo = numerador_binario.zfill(num_bits)
    # monta a string do número binário
    numero_binario = "0." + numerador_binario_completo
    # retorna o número binário como string
    return numero_binario

# exemplo de uso
frac = 0.6875
binario = fracao_para_binario(frac)
print(binario)  # imprime 0.1011

import numpy as np
import matplotlib.pyplot as plt

R_fixo = 10000
R_total = 20000
V_fonte = 15

R_pot = np.linspace(0, 10000, num=1000)

V_R1 = R_fixo/(R_fixo + R_pot) * V_fonte
V_R2 = R_pot/(R_fixo + R_pot) * V_fonte

plt.plot(R_pot, V_R1, label='Resistor Fixo')
plt.plot(R_pot, V_R2, label='Potenciômetro')
plt.axhline(y=7.5, linestyle='--', color='gray')
plt.axvline(x=10000, linestyle='--', color='gray')
plt.xlabel('Resistência do Potenciômetro (Ohms)')
plt.ylabel('Tensão (Volts)')
plt.title('Divisor de Tensão')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Dados da fonte e dos resistores
V = 15  # volts
R1 = 10000  # ohms (resistor fixo)
R2 = np.linspace(0, 10000, 1000)  # ohms (resistor variável)

# Cálculo da tensão no resistor fixo e no potenciômetro
V_R1 = (R1 / (R1 + R2)) * V
V_R2 = (R2 / (R1 + R2)) * V

# Plot do gráfico 3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(R1*np.ones_like(R2), R2, V_R2, label='Potenciômetro')
ax.plot(R1*np.ones_like(R2), R2, V_R1, label='Resistor fixo')
ax.set_xlabel('Resistência no Resistor Fixo (ohms)')
ax.set_ylabel('Resistência no Potenciômetro (ohms)')
ax.set_zlabel('Tensão (V)')
ax.legend()
plt.show()

"""////////////////////////////////////////////////////////////////////////////////

Para analisar a existência de raízes no intervalo de estudo, vamos utilizar o teorema de Bolzano que nos
fornece condições suficientes para a existência de raízes de uma função em [a, b].
"""

# Baixando e atribuindo abreviações as bibliotecas
import numpy as np
import matplotlib.pyplot as plt
# Definindo uma função F(x)
def f(x):
  y=(x)*(np.log(x))-3.2
  return y
# Definir o intervalo
# Pedindo atribuições para os valores de a e de b
a=float (input("Entre com o valor para (a): "))
b=float (input("Entre com o valor para (b): "))
#Determinando f(a) e f(b) e identificar qual é <0 e qual é >0
print("f(a)= ",f(a))
print("f(b)= ",f(b))
# Identificando se existe uma raíz no intervalo adotado
if f(a)*f(b) < 0:
  print("Existe uma raíz de f no intervalo adotado")
elif f(a)*f(b) == 0:
  print("Um dos valores atribuidos ao intervalo é uma raiz da função")
else:
  print("não existe uma raiz de f no intervalo")
# Plotando o Gráfico de f(x)
x=np.linspace(a,b,20)
y=f(x)
#plotando pontos no gráfico
plt.axhline(y=0, linestyle='--', color='gray')
plt.plot(a,f(a),'*', color='red')
plt.plot(b,f(b),'*', color='red')
plt.plot(x,y,'|', color='green')
plt.plot(x,y,color="orange",linewidth=0.8)
plt.grid()
plt.show()

"""Seja f ∶ R → R , dada por f(x) = x
ସ − 9x
ଷ − 2x
ଶ + 120x − 130. Desde que f seja contínua em R , ela é
contínua em qualquer intervalo [a; b]. Vamos construir uma tabela com valores de f para alguns valores de
x e observar as mudanças de sinal de ocorridas. Assim, é possível encontrar as raízes da função.
"""

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return round((x**4)-9*(x**3)-2*(x**2)+120*x-130, 2)
# gerar sequência de valores de x
x = np.linspace(-5, 10, 20)
# calcular os valores de f(x) para a sequência de x
fx = [f(xi) for xi in x]
# criar tabela de valores de x e f(x)
tabela = []
for xi, fxi in zip(x, fx):
  tabela.append([xi, fxi])
# imprimir tabela
print("x | f(x)")
print("-----|---------")
for linha in tabela:
  print("{:.2f} | {:.2f}".format(linha[0], linha[1]))
# plotar o gráfico da função
plt.plot(x, fx)
plt.title('Gráfico da função f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

def f(x):
    return round((x**4) - 9*(x**3) - 2*(x**2) + 120*x - 130, 2)

# Pedindo valores para o intervalo [a, b]
a = float(input("Digite o valor de a: "))
b = float(input("Digite o valor de b: "))

# Definindo o passo h
h = 0.01

# Iniciando o contador de raízes
count = 0

# Gerando valores de x e calculando f(x)
x = np.arange(a, b, h)
fx = [f(xi) for xi in x]

# Criando tabela de valores de x e f(x) e contando as raízes
tabela = []
for i, xi in enumerate(x):
    fxi = fx[i]
    tabela.append([xi, fxi])

    if i > 0:
        if np.sign(fx[i-1]) != np.sign(fxi):
            count += 1

# Imprimindo a tabela
print("x | f(x)")
print("-----|---------")
for linha in tabela:
    print("{:.2f} | {:.2f}".format(linha[0], linha[1]))

# Imprimindo o número de raízes encontradas
print("Número de raízes no intervalo: ", count)

# Plotando o gráfico da função
plt.plot(x, fx)
plt.axhline(y=0, color='black')
plt.title('Gráfico da função f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid()
plt.show()

"""round = função de aproximação de valores (number[,ndgits]).

zip = Esta função retorna uma lista de tuplas, onde a i-ésima tupla contém o i-ésimo elemento de cada um dos argumentos.

tuplas = são listas imutáveis, onde são representadas por () ao invés de [].

append = utilizado para adicionar um valor de cada vez em uma lista/tupla.

A menos que se use um software matemático, para certas funções, a tarefa de esboçar o gráfico não é
nada fácil.
Em alguns desses casos, é mais conveniente, partindo da equação f (x) = 0, obter uma equação
equivalente f1(x) = f2(x) , em que f1 e f2 sejam funções mais simples e de análise gráfica mais fácil.
Os intervalos de isolamento dos zeros de f procurados podem ser obtidos considerando as abscissas dos
pontos de intersecção dos gráficos de f1 e f2 .
Seja f :R→R , dada por: f (x) = −1 + x + x(cosx), temos que:
−1 + x + x(cosx) = 0 ⟺ x(1 + cosx) = 1 ⟺ 1 + cosx =
ଵ
௫

Portanto, isolar os zeros de f é equivalente a obter intervalos cada um dos quais contendo a abscissa de um
dos pontos de intersecção dos gráficos de f1 e f2 , no qual f1(x) = 1 + cosx e f2(x) =
ଵ
௫
, que são mais

simples de ser esboçados do que o gráfico de f(x).
"""

import numpy as np
import matplotlib.pyplot as plt
# definindo as funções f(x) e g(x)
def f(x):
  return 1+np.cos(x)
def g(x):
  return 1/x
# criando os valores de x (de 0 a 10)
x = np.linspace(1, 10, 100)
# plotando as funções no mesmo gráfico
plt.plot(x, f(x), label='f(x)')
plt.plot(x, g(x), label='g(x)')
# adicionando título e legendas aos eixos
plt.title('Funções f(x) e g(x)')
plt.xlabel('x')
plt.ylabel('y')
# adicionando a legenda das funções
plt.legend()
# exibindo o gráfico
plt.grid()
plt.show()

#Importando as bibliotecas matemáticas
import numpy as np
import matplotlib.pyplot as plt

#Definindo a equação do paraquedista
def f(x):
  return round((667.78/x)*(1 - np.exp(-0.147*x))-40)

# Pedindo atribuições para os valores de a e de b
a = float(input("Entre com o valor para (a): "))
b = float(input("Entre com o valor para (b): "))

#Determinando f(a) e f(b) e identificar qual é <0 e qual é >0
print("f(a) = ", f(a))
print("f(b) = ", f(b))

#Compondo o algoritmo do Método da Bisseção
while True:
  c = (a + b) / 2
  print("c = ", c)
  print("f(c) = ", f(c))
  if f(a) * f(c) < 0:
    b = c
  else:
    a = c
  #Verificar a precisão desejada
  error = abs((c - (a + b) / 2) / c) * 100
  if error < 0.5:
    break

print("Raiz encontrada: ", c)
print("Erro relativo: ", error, "%")

import numpy as np
import sys
import matplotlib.pyplot as plt

def f(x):
  return (667.78/x)*(1 - np.exp(-0.147*x))-40

a = float(input("Entre com o valor para (a): "))
b = float(input("Entre com o valor para (b): "))

if f(a) * f(b) >= 0:
  print("Não é possível encontrar a raiz neste intervalo.")
  sys.exit()

while True:
  c = (a + b) / 2
  print("c = ", c)
  print("f(c) = ", f(c))
  if f(a) * f(c) < 0:
    b = c
  else:
    a = c

  error = abs((c - (a + b) / 2) / c) * 100
  if error < 0.5:
    break

print("Raiz encontrada: ", c)
print("Erro relativo: ", error, "%")

# Plotando o gráfico da função
x = np.linspace(a, b, 1000)
plt.plot(x, f(x), 'b-', label='f(x)')
plt.plot(c, f(c), 'ro', label='raiz')
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
# função f(x) que desejamos encontrar a raiz
  return x * np.log(x) - 3.2
a = 1 # limite inferior do intervalo
b = 3 # limite superior do intervalo
tolerance = 0.0005 # critério de parada de 0.5%
# Implementação do método da bisseção
fa = f(a)
fb = f(b)
x = (a + b) / 2
fx = f(x)
erro_rel = 1
x_vals = [a, b, x]
y_vals = [fa, fb, fx]
while erro_rel > tolerance:
  if fx == 0:
    break
  elif (fa)*(fx)>0:
    a = x
    fa = fx
  else:
    b = x
    fb = fx
  x_antigo = x
  x = (a + b) / 2
  fx = f(x)
  erro_rel =round(abs(x - x_antigo) / abs(x),4)
  x_vals.append(x)
  y_vals.append(fx)
# Obtendo resultados
root = x
print("O valor aproximado da raiz da função,segundo o método da bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
plt.show()

import math

# Define a função a ser resolvida
def f(x):
    return math.cos(x) - x**3

# Define a derivada da função
def f_deriv(x):
    return -math.sin(x) - 3*(x**2)

# Define o método de Newton-Raphson
def newton_raphson(x, tol):
    n_iter = 0
    while abs(f(x)) > tol:
        x = x - f(x)/f_deriv(x)
        n_iter += 1
        if n_iter > 100:
            print("O método não convergiu.")
            return None
    return x

# Chama a função de Newton-Raphson com um valor inicial e uma tolerância
x0 = 1.0
tol = 1e-6
raiz = newton_raphson(x0, tol)

# Imprime a raiz encontrada
print("Raiz: ", raiz)

"""Nesse exemplo, definimos uma função f(x) que será resolvida pelo método numérico de Newton-Raphson. Também definimos a derivada da função em f_deriv(x). Em seguida, definimos a função newton_raphson(x, tol), que implementa o método de Newton-Raphson. Essa função recebe um valor inicial x e uma tolerância tol, e retorna a raiz encontrada. Finalmente, chamamos a função newton_raphson(x0, tol) com um valor inicial x0 e uma tolerância tol, e imprimimos a raiz encontrada."""

import sympy as sym

# Definir a variável simbólica x
x = sym.Symbol('x')

# Digite a equação como uma string
equacao_str = input("Digite a equação: ")

# Converter a string em uma expressão SymPy
equacao = sym.sympify(equacao_str)

# Digite o ponto inicial como um float
ponto_inicial = float(input("Digite o ponto inicial: "))

# Definir a derivada da equação
derivada = sym.diff(equacao, x)

# Definir a tolerância e o número máximo de iterações
tolerancia = 1e-8
max_iteracoes = 100

# Iniciar a iteração do método de Newton-Raphson
xk = ponto_inicial
for i in range(max_iteracoes):
    # Calcular o valor da função e sua derivada no ponto atual
    fxk = equacao.subs(x, xk)
    dfxk = derivada.subs(x, xk)

    # Calcular o próximo valor de x usando o método de Newton-Raphson
    xk1 = xk - fxk/dfxk

    # Verificar a condição de parada
    if abs(xk1 - xk) < tolerancia:
        break

    # Atualizar o valor de xk
    xk = xk1

# Imprimir o resultado
print("A raiz é:", xk)

import numpy as np
import matplotlib.pyplot as plt

V = np.array([5, 4.7, 4.46, 4.20, 3.82, 3.34, 2.90, 2.27, 1.48, 0.75])
I = np.array([5.02, 5.31, 5.57, 5.83, 6.22, 6.71, 7.15, 7.37, 7.62, 7.45])

plt.plot(I, V, 'o', label='Pontos experimentais')
plt.xlabel('I (mA)')
plt.ylabel('V (Volts)')

# ajuste linear dos pontos
m, b = np.polyfit(I, V, 1)
plt.plot(I, m*I + b, '-', label='Regressão linear')

# raiz da equação
raiz = -b/m
print(f"A raiz da equação é {raiz:.2f} mA")

plt.grid()
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Dados do problema
V = np.array([5, 4.7, 4.46, 4.20, 3.82, 3.34, 2.90, 2.27, 1.48, 0.75])
I = np.array([5.02, 5.31, 5.57, 5.83, 6.22, 6.71, 7.15, 7.37, 7.62, 7.45])

# Função que retorna o valor de V para um dado valor de I
def f(I):
    return -0.9335*I + 6.2735

# Plot dos dados
plt.plot(I, V, 'o')
plt.xlabel('I (mA)')
plt.ylabel('V (Volts)')
plt.title('Curva característica de um gerador elétrico real')

# Ajuste linear dos pontos
m, b = np.polyfit(I, V, 1)
plt.plot(I, m*I + b, '-', label='Regressão linear')

# Cálculo da raiz da equação
a = I[0]  # Início do intervalo
b = I[-1]  # Fim do intervalo
tolerancia = 1e-6  # Tolerância do método

while abs(b - a) > tolerancia:
    x = (a + b) / 2
    if f(a) * f(x) < 0:
        b = x
    else:
        a = x

raiz = (a + b) / 2
print(f"A raiz da equação é {raiz:.2f} mA")

# Adição de legenda
plt.legend()

plt.grid()
plt.show()

# Baixando e atribuindo abreviações as bibliotecas
import numpy as np
import matplotlib.pyplot as plt
# Definindo uma função F(x)
def f(x):
  y=(x)*(np.cos(x))-(2*x**2)+(3*x)-1
  return y
# Definir o intervalo
# Pedindo atribuições para os valores de a e de b
a=float (input("Entre com o valor para (a): "))
b=float (input("Entre com o valor para (b): "))
#Determinando f(a) e f(b) e identificar qual é <0 e qual é >0
print("f(a)= ",f(a))
print("f(b)= ",f(b))
# Identificando se existe uma raíz no intervalo adotado
if f(a)*f(b) < 0:
  print("Existe uma raíz de f no intervalo adotado")
elif f(a)*f(b) == 0:
  print("Um dos valores atribuidos ao intervalo é uma raiz da função")
else:
  print("não existe uma raiz de f no intervalo")
# Plotando o Gráfico de f(x)
x=np.linspace(a,b,20)
y=f(x)
#plotando pontos no gráfico
plt.axhline(y=0, linestyle='--', color='gray')
plt.plot(a,f(a),'*', color='red')
plt.plot(b,f(b),'*', color='red')
plt.plot(x,y,'|', color='green')
plt.plot(x,y,color="orange",linewidth=0.8)
plt.grid()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
import math

def f(x):
    return round(x**3+(4.001*x**2)+(4.002*x)+1.001, 2)

# Pedindo valores para o intervalo [a, b]
a = float(input("Digite o valor de a: "))
b = float(input("Digite o valor de b: "))

# Definindo o passo h
h = 0.01

# Iniciando o contador de raízes
count = 0

# Gerando valores de x e calculando f(x)
x = np.arange(a, b, h)
fx = [f(xi) for xi in x]

# Criando tabela de valores de x e f(x) e contando as raízes
tabela = []
for i, xi in enumerate(x):
    fxi = fx[i]
    tabela.append([xi, fxi])

    if i > 0:
        if np.sign(fx[i-1]) != np.sign(fxi):
            count += 1

# Imprimindo a tabela
print("x | f(x)")
print("-----|---------")
for linha in tabela:
    print("{:.2f} | {:.2f}".format(linha[0], linha[1]))

# Imprimindo o número de raízes encontradas
print("Número de raízes no intervalo: ", count)

# Plotando o gráfico da função
plt.plot(x, fx)
plt.axhline(y=0, color='black')
plt.title('Gráfico da função f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
# definindo as funções f(x) e g(x)
def f(x):
  return x*np.cos(x)
def g(x):
  return (2*x**2)-(3*x)+1
# criando os valores de x (de 0 a 10)
x = np.linspace(1, 10, 100)
# plotando as funções no mesmo gráfico
plt.plot(x, f(x), label='f(x)')
plt.plot(x, g(x), label='g(x)')
# adicionando título e legendas aos eixos
plt.title('Funções f(x) e g(x)')
plt.xlabel('x')
plt.ylabel('y')
# adicionando a legenda das funções
plt.legend()
# exibindo o gráfico
print("A função ficara do tipo x*cos(x) = 2x²-3x+1")
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt


def f(x):
  return 3*np.sin(4*x-1)+2*x

a = 0 # limite inferior do intervalo
b = 100 # limite superior do intervalo
tolerance = 0.001 # critério de parada de 0.5%
# Implementação do método da bisseção
fa = f(a)
fb = f(b)
x = (a + b) / 2
fx = f(x)
erro_rel = 1
x_vals = [a, b, x]
y_vals = [fa, fb, fx]
while erro_rel > tolerance:
  if fx == 0:
    break
  elif (fa)*(fx)>0:
    a = x
    fa = fx
  else:
    b = x
    fb = fx
  x_antigo = x
  x = (a + b) / 2
  fx = f(x)
  erro_rel =round(abs(x - x_antigo) / abs(x),4)
  x_vals.append(x)
  y_vals.append(fx)
# Obtendo resultados
root = x
print("O valor aproximado da raiz da função,segundo o método da bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
# função f(x) que desejamos encontrar a raiz
  return  3*np.sin(4*x-1)+2*x
a = -10 # limite inferior do intervalo
b = 10 # limite superior do intervalo
tolerance = 0.005 # critério de parada de 0.5%
# Implementação do método da falsa posição
fa = f(a)
fb = f(b)
x = ((a*f(b) - b*f(a))/(f(b)-f(a)))
fx = f(x)
x_vals = [a, b, x]
y_vals = [fa, fb, fx]
contador = 1 # inicializando o contador
while abs(fx) > tolerance:
  contador += 1 # incrementando o contador a cada iteração
  if fx == 0:
    break
  elif (fa)*(fx) > 0:
    a = x
    fa = fx
  else:
    b = x
    fb = fx
  x_antigo = x
  x = ((a*f(b) - b*f(a))/(f(b)-f(a)))
  fx = f(x)
  erro_rel = round(abs(x - x_antigo) / abs(x), 4)
  x_vals.append(x)
  y_vals.append(fx)
  # Obtendo resultados
root = x
print("O valor aproximado da raiz da função, segundo o método da falsa posição é:"
, root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
print("A quantidade de iterações foi:", contador) # imprimindo o contador
# Plotando gráfico
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals, color="orange", linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--', linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Falsa Posição')
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return np.exp(-x)-x
def g(x):
  return np.exp(-x)
# Valores iniciais para x
a = 0.2
tol = 0.005
max_iter = 100
fig, ax = plt.subplots(figsize=(8,6))#cria a figura e controla o tamanho
x = np.linspace(0, 1, 1000)
y = x
ax.plot(x, y, 'b-', label='y=x')
ax.plot(x, g(x), 'g-', label='g(x)')
ax.plot(x, f(x), 'r-', label='f(x)')
ax.plot([a, a], [0, g(a)], 'k--', label='x0')
xs = [a]
contador = 1
erro_rel = tol + 1
#Loop while para executar o método do ponto fixo enquanto o erro relativo
#for maior que a tolerância e o número de iterações não atingir o máximo:
while erro_rel > tol and contador < max_iter:
  x = g(a)
  #Adicionar o valor de x à lista de valores de x e/
  #calcular o erro relativo com base nos dois últimos valores:
  xs.append(x)
  erro_rel = abs((xs[-1] - xs[-2]) / xs[-1])
  #Plote uma linha tracejada e pontos para representar o valor de x e uma legenda para as iterações:
  ax.plot(xs[-1], f(xs[-1]), 'o', markersize=4, color='black')
  ax.plot([a, x], [g(a), x], 'm--', label='x{}'.format(contador))
  ax.plot([x, x], [0, g(x)], 'k--')
  #Atualize o valor de a e o contador para a próxima iteração:
  #Verifique se o método convergiu para a raiz ou atingiu o número máximo de iterações:
  a = x
  contador += 1
if contador == max_iter:
  print("O método do ponto fixo não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o método do ponto fixo é:", xs[-1])
  print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
  print("A quantidade de iterações foi:", contador)
ax.plot(xs[-1], g(xs[-1]), 'go', label='intercessão')
ax.plot(a, f(a), 'ro', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
ax.legend(fontsize = 6)
plt.xlabel('x', fontsize=14)
plt.ylabel('f(x)', fontsize=14)
plt.title('Método do ponto fixo', fontsize=16)
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
return x**3 - 2*x - 5
def df(x):
return 3*x**2 - 2
# Valor inicial para x
x0 = 2
tol = 0.005
max_iter = 100
fig, ax = plt.subplots()
x = np.linspace(2, 3, 1000)
y = f(x)
ax.plot(x, y, label='f(x)')
contador = 0 # inicializando o contador
xs = [] # lista para armazenar os valores de x a cada iteração
erro_rel = tol + 1 # erro relativo inicial maior que a tolerância
#Loop while para executar o método de Newton enquanto o erro relativo
#for maior que a tolerância e o número de iterações não atingir o máximo:
while erro_rel > tol and contador < max_iter:
fx = f(x0)
dfx = df(x0)
if dfx == 0:
break
x = x0 - fx / dfx
#Adicionar o valor de x à lista de valores de x e/
#calcular o erro relativo com base nos dois últimos valores:
xs.append(x)
if len(xs) > 1:
erro_rel = abs((xs[-1] - xs[-2]) / xs[-1])
#Plote uma linha vermelha tracejada para representar a tangente no ponto x0, um po
nto vermelho
#para indicar a posição de x0 na curva e uma legenda para as iterações:
ax.plot([x0, x], [0, fx], 'r--', label='Tangente')
ax.plot(x0, fx, 'ro', label='x{}'.format(contador+1))
#Atualize o valor de x0 e o contador para a próxima iteração:
#Verifique se o método convergiu para a raiz ou atingiu o número máximo de iteraçõ
es:
x0 = x
contador += 1
# impressão dos resultados
if contador == max_iter:
print("O método de Newton não convergiu após %d iterações."%contador)
else:
print("O valor aproximado da raiz da função, segundo o método de Newton é:", x
s[-1])
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,
"%")
print("A quantidade de iterações foi:", contador)
ax.plot(x0, f(x0), 'go', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
ax.legend(fontsize = 8)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método de Newton-Raphson')
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
return x**3 - 2*x - 5
# Valores iniciais para x
a = 2
b = 3
tol = 0.005
max_iter = 100
fig, ax = plt.subplots()
x = np.linspace(2,3, 1000)
y = f(x)
ax.plot(x, y, label='f(x)')
contador = 0 # inicializando o contador
xs = [] # lista para armazenar os valores de x a cada iteração
erro_rel = tol + 1 # erro relativo inicial maior que a tolerância
#Loop while para executar o método da secante enquanto o erro relativo
#for maior que a tolerância e o número de iterações não atingir o máximo:
while erro_rel > tol and contador < max_iter:
fx1 = f(a)
fx2 = f(b)
x = ((a*fx2 - b*fx1)/(fx2-fx1))
#Adicionar o valor de x à lista de valores de x e/
#calcular o erro relativo com base nos dois últimos valores:
xs.append(x)
if contador > 1:
erro_rel = abs((xs[-1] - xs[-2]) / xs[-1])
#Plote uma linha vermelha tracejada para representar a secante entre os pontos a e
b,
#um ponto vermelho para indicar a posição de x na curva e uma legenda para as iter
ações:
ax.plot([a, b], [f(a), f(b)], 'r--', label='Secante')
ax.plot(x, f(x), 'ro', label='x{}'.format(contador))
#Atualize os valores de a e b e o contador para a próxima iteração:
#Verifique se o método convergiu para a raiz ou atingiu o número máximo de iteraçõ
es:
a = b
b = x
contador += 1
# impressão dos resultados
if contador == max_iter:
print("O método da secante não convergiu após %d iterações."%contador)
else:
print("O valor aproximado da raiz da função, segundo o método da secante é:",
xs[-1])
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,
"%")
print("A quantidade de iterações foi:", contador)
ax.plot(xs[-1], f(xs[-1]), 'go', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
ax.legend(fontsize = 8)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Secante')
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
    return round(5*np.sin(x**2)-np.exp(x/10), 3)
# gerar sequência de valores de x
x = np.linspace(0, 10, 20)
# calcular os valores de f(x) para a sequência de x
fx = [f(xi) for xi in x]
# criar tabela de valores de x e f(x)
tabela = []
for xi, fxi in zip(x, fx):
    tabela.append([xi, fxi])
# imprimir tabela
print("x    | f(x)")
print("-----|---------")
for linha in tabela:
    print("{:.2f} | {:.2f}".format(linha[0], linha[1]))
# plotar o gráfico da função
plt.plot(x, fx)
plt.title('Gráfico da função f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
 return 5*np.sin(x**2)-np.exp(x/10)
xi = 0.01
xs = 0.53
tol = 0.0001
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (a+b)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0

while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif (fxi)*(fxr) > 0:
    xi = xr
    fxi = fxr
  else:
   xs = xr
   fxs = fxr
  x_antigo = xr
  xr = (a+b)/2
  fxr = f(xr)
  erro_rel =round(abs((xr - x_antigo)/xr),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o Identifique o método é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')

x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Valores de B (eixo x)
B = np.array([-1000, -907, -803, -709, -603, -488, -394, -299, -205, -91, 4, 92, 204, 302, 402, 505, 612, 698, 806, 900, 1000])

# Valores de V (eixo y)
V = np.array([0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.25, 3.5, 3.75, 4.0, 4.25, 4.5, 4.75, 5.0])

# Realizando a regressão linear
slope, intercept = np.polyfit(B, V, 1)

# Gerando os valores preditos para a regressão linear
B_pred = np.linspace(0, 100, 100)
V_pred = slope * B_pred + intercept

# Plotando os pontos e a regressão linear
plt.scatter(B, V, label='Pontos')
plt.plot(B_pred, V_pred, color='red', label='Regressão Linear')
plt.xlabel('B (Gauss)')
plt.ylabel('V (Volts)')
plt.title('Relação entre B e V')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Valores de B (eixo x)
B = np.array([-1000, -907, -803, -709, -603, -488, -394, -299, -205, -91, 4, 92, 204, 302, 402, 505, 612, 698, 806, 900, 1000])

# Valores de V (eixo y)
V = np.array([0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.25, 3.5, 3.75, 4.0, 4.25, 4.5, 4.75, 5.0])

# Realizando a regressão linear
slope, intercept = np.polyfit(B, V, 1)

# Gerando os valores preditos para a regressão linear
B_pred = np.linspace(-1000, 1000, 100)
V_pred = slope * B_pred + intercept

# Plotando a regressão linear
plt.plot(B_pred, V_pred, color='red', label='Regime Linear')
plt.axhline(y=2.5, color='blue', linestyle='--', label='V = 2.5V')
plt.xlabel('B (Gauss)')
plt.ylabel('V (Volts)')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# valores de corrente e tensão
I = np.array([0.5, 1, 2, 3, 4, 4.5])  # corrente em A
V = np.array([700, 568, 580, 192, 29.4, 0])  # tensão em V

# cálculo da resistência R
R = np.sum(I * V) / np.sum(I ** 2)

# plot do gráfico
plt.plot(I, V, 'o', label='Dados experimentais')
plt.plot(I, R*I, '-', label='Ajuste linear')
plt.xlabel('Altura')
plt.ylabel('Vazão)')
plt.title(f'Reta R = {R:.2f}')
plt.legend()
plt.grid
plt.show()

import matplotlib.pyplot as plt

# Dados
x = [0.5, 1, 2, 3, 4, 4.5]
y = [700, 568, 580, 192, 29.4, 0]

# Plotagem do gráfico
plt.plot(x, y, '-o')

# Configurações dos eixos
plt.xlabel('x')
plt.ylabel('y')

# Exibição do gráfico
plt.xlabel('Altura (m.c.a)')
plt.ylabel('Vazão média (l/h)')
plt.grid()
plt.show()

import numpy as np

E = np.array([[5, 1, -1, 0, -1],
              [1, 6, -3, -1, 0],
              [-2, 3, 1, 5, 2],
              [4, 5, 2, 8, 6]], dtype='double')
print(E)

n_rows, n_cols = E.shape

# Eliminação de Gauss
for i in range(n_rows-1):
    for j in range(i+1, n_rows):
        factor = E[j, i] / E[i, i]
        E[j, i:] -= factor * E[i, i:]

print(E)

# Substituição regressiva
x = np.zeros(n_rows)

for i in range(n_rows-1, -1, -1):
    x[i] = (E[i, -1] - np.dot(E[i, :-1], x)) / E[i, i]

print(x)

import numpy as np

E = np.array([[1,3,1,1],
              [2,1,-2,0],
              [4,2,1,1]], dtype='double')
print(E)

# L2 <-> L1
aux = np.copy(E[1,:])
E[1,:] = np.copy(E[0,:])
E[0,:] = np.copy(aux)
print(E)

# zera E[1:2,0]
E[1,:] = E[1,:] - (E[1,0]/E[0,0])*E[0,:]
E[2,:] = E[2,:] - (E[2,0]/E[0,0])*E[0,:]
print(E)

# zera E[2,1]
E[2,:] = E[2,:] - (E[2,1]/E[1,1])*E[1,:]
print(E)

# sub. regressiva
x = np.zeros(3)
x[2] = E[2,3]/E[2,2]
x[1] = (E[1,3] - E[1,2]*x[2])/E[1,1]
x[0] = (E[0,3] - E[0,2]*x[2] - E[0,1]*x[1])/E[0,0]
print(x)

# Valor real da solução
x_real = np.array([1, -1, 2])

# Cálculo do erro relativo e verificação da tolerância
tolerancia = 0.01  # Valor de tolerância definido
erro_rel = np.inf  # Inicialização do erro relativo como infinito

while erro_rel > tolerancia:
    # Atualização dos valores
    # ... (coloque aqui o código para atualizar os valores do sistema)

    # Cálculo do erro relativo
    erro_rel = np.max(np.abs(x - x_real) / np.abs(x_real))

    # Se o erro relativo for menor ou igual à tolerância, interrompe o loop
    if erro_rel <= tolerancia:
        break

# Exibição dos resultados
if erro_rel <= tolerancia:
    print("A solução atingiu a tolerância desejada.")
else:
    print("A solução não atingiu a tolerância desejada.")

import numpy as np

E = np.array([[52, 30, 18, 4.8],
              [20, 50, 30, -5.8],
              [25, 20, 55, 5.7]], dtype='double')
print(E)

n_rows, n_cols = E.shape

# Eliminação de Gauss
for i in range(n_rows-1):
    for j in range(i+1, n_rows):
        factor = E[j, i] / E[i, i]
        E[j, i:] -= factor * E[i, i:]

print(E)

# Substituição regressiva
x = np.zeros(n_rows)

for i in range(n_rows-1, -1, -1):
    x[i] = (E[i, -1] - np.dot(E[i, :-1], x)) / E[i, i]

print(x)

import numpy as np

E = np.array([[2, 1, -1, 8],
              [-3, 0, 2, -11],
              [-2, 1, 2, -3]], dtype='double')
print(E)

n_rows, n_cols = E.shape # matriz 3x4

# Eliminação de Gauss
for i in range(n_rows-1):
    for j in range(i+1, n_rows):
        factor = E[j, i] / E[i, i]
        E[j, i:] -= factor * E[i, i:]

print(E)

# Substituição regressiva
x = np.zeros(n_rows)

for i in range(n_rows-1, -1, -1):
    x[i] = (E[i, -1] - np.dot(E[i, :-1], x)) / E[i, i]

# Solução de referência (exemplo)
x_ref = np.array([2, -1, 3])

# Cálculo do erro relativo
erro_rel = np.abs((x - x_ref) / x_ref)

print("Valores das incógnitas:")
print(x)

print("Erros relativos:")
print(erro_rel)

import numpy as np

def solve_linear_system(A, b):
  n = len(A)
  det_A = np.linalg.det(A)
  if det_A != 0:
    x = np.linalg.solve(A, b)
    return "Sistema Possível Determinado", x
  else:
    rank_A = np.linalg.matrix_rank(A)
    rank_augmented = np.linalg.matrix_rank(np.column_stack((A, b)))
    if rank_A == rank_augmented:
      return "Sistema Possível Indeterminado", []
    else:
      return "Sistema Impossível", []
# Exemplo de sistema linear
A = np.array([[3, 1,0,-1], [1,3,1,1],[0,1,3,-1],[-1,1,-1,4]])
b = np.array([10,15,10,0])
result, solution = solve_linear_system(A, b)
print("Resultado:", result)
if len(solution) > 0:
  print("Solução:", solution)

import numpy as np

def eliminacao_gauss(a, b):
  # Verifica se as dimensões de 'a' e 'b' são compatíveis
  if len(a) != len(b):
    raise ValueError("As dimensões de 'a' e 'b' não são compatíveis.")
  # Converte a matriz aumentada para o tipo 'float'
  matriz_aumentada = np.column_stack((a.astype(float), b.astype(float)))
  # Imprime a matriz aumentada inicial
  print("Matriz aumentada inicial:")
  print(matriz_aumentada)
  print()
  # Verifica e troca as linhas se o pivô for zero
  n = len(a)
  for i in range(n):
    # Verifica se o pivô é zero
    if matriz_aumentada[i, i] == 0:
      for j in range(i+1, n):
        if matriz_aumentada[j, i] != 0:
          matriz_aumentada[[i, j]] = matriz_aumentada[[j, i]]
          break
      else:
        raise ValueError("O sistema não possui solução única.")
    # Aplica o processo de eliminação de Gauss
    for j in range(i+1, n):
      multiplicador = matriz_aumentada[j, i] / matriz_aumentada[i, i]
      matriz_aumentada[j] -= multiplicador * matriz_aumentada[i]

  # Imprime a matriz aumentada triangular resultante
  print("Matriz aumentada triangular superior resultante:")
  print(matriz_aumentada)
  print()
  # Imprime a matriz triangular resultante da eliminação de Gauss
  matriz_triangular = matriz_aumentada[:, :-1]
  print("Matriz triangular:")
  print(matriz_triangular)
  print()
  # Realiza a substituição para obter os valores de b
  x = np.zeros(n)
  for i in range(n-1, -1, -1):
    x[i] = (matriz_aumentada[i, -1] - np.dot(matriz_aumentada[i, i+1:-1], x[i+1:])) / matriz_aumentada[i, i]
  # Calcula os valores de b encontrados
  b_calculado = np.dot(a, x)
  # Determina o erro relativo para cada valor de b
  erro_relativo = np.abs(b - b_calculado) / np.abs(b)
  return x, b_calculado, erro_relativo
# Exemplo de uso
a = np.array([[-2, 3, -1],
[4, 10, -6],
[2, 1, -4]])
b = np.array([-5, 2, -9])
x, b_calculado, erro_relativo = eliminacao_gauss(a, b)
# Formatação dos resultados com 5 casas decimais
x_formatado = [f"{valor:.5f}" for valor in x]
b_calculado_formatado = [f"{valor:.5f}" for valor in b_calculado]
erro_relativo_formatado = [f"{valor:.5f}" for valor in erro_relativo]
print("Valores de x encontrados:", x_formatado)
print("Valores de b calculados:", b_calculado_formatado)
print("Erro relativo:", erro_relativo_formatado)

import numpy as np

def eliminacao_gauss(a, b):
  # Verifica se as dimensões de 'a' e 'b' são compatíveis
  if len(a) != len(b):
    raise ValueError("As dimensões de 'a' e 'b' não são compatíveis.")
  # Converte a matriz aumentada para o tipo 'float'
  matriz_aumentada = np.column_stack((a.astype(float), b.astype(float)))
  # Imprime a matriz aumentada inicial
  print("Matriz aumentada inicial:")
  print(matriz_aumentada)
  print()
  # Verifica e troca as linhas se o pivô for zero
  n = len(a)
  for i in range(n):
    # Verifica se o pivô é zero
    if matriz_aumentada[i, i] == 0:
      for j in range(i+1, n):
        if matriz_aumentada[j, i] != 0:
          matriz_aumentada[[i, j]] = matriz_aumentada[[j, i]]
          break
      else:
        raise ValueError("O sistema não possui solução única.")
    # Aplica o processo de eliminação de Gauss
    for j in range(i+1, n):
      multiplicador = matriz_aumentada[j, i] / matriz_aumentada[i, i]
      matriz_aumentada[j] -= multiplicador * matriz_aumentada[i]

  # Imprime a matriz aumentada triangular resultante
  print("Matriz aumentada triangular superior resultante:")
  print(matriz_aumentada)
  print()
  # Imprime a matriz triangular resultante da eliminação de Gauss
  matriz_triangular = matriz_aumentada[:, :-1]
  print("Matriz triangular:")
  print(matriz_triangular)
  print()
  # Realiza a substituição para obter os valores de b
  x = np.zeros(n)
  for i in range(n-1, -1, -1):
    x[i] = (matriz_aumentada[i, -1] - np.dot(matriz_aumentada[i, i+1:-1], x[i+1:])) / matriz_aumentada[i, i]
  # Calcula os valores de b encontrados
  b_calculado = np.dot(a, x)
  # Determina o erro relativo para cada valor de b
  erro_relativo = np.abs(b - b_calculado) / np.abs(b)
  return x, b_calculado, erro_relativo
# Exemplo de uso
a = np.array([[5, 1, -1, 0],
[1, 6, 3, -1],
[-2, 3, 1, 5],
[4, 5, 2, 8]])
b = np.array([-1, 0, 2, 6])
x, b_calculado, erro_relativo = eliminacao_gauss(a, b)
# Formatação dos resultados com 5 casas decimais
x_formatado = [f"{valor:.5f}" for valor in x]
b_calculado_formatado = [f"{valor:.5f}" for valor in b_calculado]
erro_relativo_formatado = [f"{valor:.5f}" for valor in erro_relativo]
print("Valores de x encontrados:", x_formatado)
print("Valores de b calculados:", b_calculado_formatado)
print("Erro relativo:", erro_relativo_formatado)

import numpy as np

def eliminacao_gauss(a, b):
  # Verifica se as dimensões de 'a' e 'b' são compatíveis
  if len(a) != len(b):
    raise ValueError("As dimensões de 'a' e 'b' não são compatíveis.")
  # Converte a matriz aumentada para o tipo 'float'
  matriz_aumentada = np.column_stack((a.astype(float), b.astype(float)))
  # Imprime a matriz aumentada inicial
  print("Matriz aumentada inicial:")
  print(matriz_aumentada)
  print()
  # Verifica e troca as linhas se o pivô for zero
  n = len(a)
  for i in range(n):
    # Verifica se o pivô é zero
    if matriz_aumentada[i, i] == 0:
      for j in range(i+1, n):
        if matriz_aumentada[j, i] != 0:
          matriz_aumentada[[i, j]] = matriz_aumentada[[j, i]]
          break
      else:
        raise ValueError("O sistema não possui solução única.")
    # Aplica o processo de eliminação de Gauss
    for j in range(i+1, n):
      multiplicador = matriz_aumentada[j, i] / matriz_aumentada[i, i]
      matriz_aumentada[j] -= multiplicador * matriz_aumentada[i]

  # Imprime a matriz aumentada triangular resultante
  print("Matriz aumentada triangular superior resultante:")
  print(matriz_aumentada)
  print()
  # Imprime a matriz triangular resultante da eliminação de Gauss
  matriz_triangular = matriz_aumentada[:, :-1]
  print("Matriz triangular:")
  print(matriz_triangular)
  print()
  # Realiza a substituição para obter os valores de b
  x = np.zeros(n)
  for i in range(n-1, -1, -1):
    x[i] = (matriz_aumentada[i, -1] - np.dot(matriz_aumentada[i, i+1:-1], x[i+1:])) / matriz_aumentada[i, i]
  # Calcula os valores de b encontrados
  b_calculado = np.dot(a, x)
  # Determina o erro relativo para cada valor de b
  erro_relativo = np.abs(b - b_calculado) / np.abs(b)
  return x, b_calculado, erro_relativo
# Exemplo de uso
a = np.array([[0.52, 0.3, 0.18],
[0.2, 0.5, 0.3],
[0.25, 0.2, 0.55]])
b = np.array([4800, 5800, 5700])
x, b_calculado, erro_relativo = eliminacao_gauss(a, b)
# Formatação dos resultados com 5 casas decimais
x_formatado = [f"{valor:.5f}" for valor in x]
b_calculado_formatado = [f"{valor:.5f}" for valor in b_calculado]
erro_relativo_formatado = [f"{valor:.5f}" for valor in erro_relativo]
print("Valores de x encontrados:", x_formatado)
print("Valores de b calculados:", b_calculado_formatado)
print("Erro relativo:", erro_relativo_formatado)

import numpy as np

def solve_linear_system(A, b):
  n = len(A)
  det_A = np.linalg.det(A)
  if det_A != 0:
    x = np.linalg.solve(A, b)
    return "Sistema Possível Determinado", x
  else:
    rank_A = np.linalg.matrix_rank(A)
    rank_augmented = np.linalg.matrix_rank(np.column_stack((A, b)))
    if rank_A == rank_augmented:
      return "Sistema Possível Indeterminado", []
    else:
      return "Sistema Impossível", []
# Exemplo de sistema linear
A = np.array([[0.52, 0.3, 0.18], [0.2, 0.5, 0.3],[0.25, 0.2, 0.55]])
b = np.array([4800,5800, 5700])
result, solution = solve_linear_system(A, b)
print("Resultado:", result)
if len(solution) > 0:
  print("Solução:", solution)

import numpy as np

def eliminacao_gauss(a, b):
  # Verifica se as dimensões de 'a' e 'b' são compatíveis
  if len(a) != len(b):
    raise ValueError("As dimensões de 'a' e 'b' não são compatíveis.")
  # Converte a matriz aumentada para o tipo 'float'
  matriz_aumentada = np.column_stack((a.astype(float), b.astype(float)))
  # Imprime a matriz aumentada inicial
  print("Matriz aumentada inicial:")
  print(matriz_aumentada)
  print()
  # Verifica e troca as linhas se o pivô for zero
  n = len(a)
  for i in range(n):
    # Verifica se o pivô é zero
    if matriz_aumentada[i, i] == 0:
      for j in range(i+1, n):
        if matriz_aumentada[j, i] != 0:
          matriz_aumentada[[i, j]] = matriz_aumentada[[j, i]]
          break
      else:
        raise ValueError("O sistema não possui solução única.")
    # Aplica o processo de eliminação de Gauss
    for j in range(i+1, n):
      multiplicador = matriz_aumentada[j, i] / matriz_aumentada[i, i]
      matriz_aumentada[j] -= multiplicador * matriz_aumentada[i]

  # Imprime a matriz aumentada triangular resultante
  print("Matriz aumentada triangular superior resultante:")
  print(matriz_aumentada)
  print()
  # Imprime a matriz triangular resultante da eliminação de Gauss
  matriz_triangular = matriz_aumentada[:, :-1]
  print("Matriz triangular:")
  print(matriz_triangular)
  print()
  # Realiza a substituição para obter os valores de b
  x = np.zeros(n)
  for i in range(n-1, -1, -1):
    x[i] = (matriz_aumentada[i, -1] - np.dot(matriz_aumentada[i, i+1:-1], x[i+1:])) / matriz_aumentada[i, i]
  # Calcula os valores de b encontrados
  b_calculado = np.dot(a, x)
  # Determina o erro relativo para cada valor de b
  erro_relativo = np.abs(b - b_calculado) / np.abs(b)
  return x, b_calculado, erro_relativo
# Exemplo de uso
a = np.array([[6, -3, -3, 0, 0],
[-3, 6, 0, -3, 0],
[-3, 0, 6, -1, -2],
[0, -3, -1, 5, 0],
[0, 0, -2, 0, 3]])
b = np.array([0, 6, 0, 2, -3])
x, b_calculado, erro_relativo = eliminacao_gauss(a, b)
# Formatação dos resultados com 5 casas decimais
x_formatado = [f"{valor:.5f}" for valor in x]
b_calculado_formatado = [f"{valor:.5f}" for valor in b_calculado]
erro_relativo_formatado = [f"{valor:.5f}" for valor in erro_relativo]
print("Valores de x encontrados:", x_formatado)
print("Valores de b calculados:", b_calculado_formatado)
print("Erro relativo:", erro_relativo_formatado)

import numpy as np
import matplotlib.pyplot as plt

def jacobi(A, b, x0, tol=1e-6, max_iter=1000):
  n = A.shape[0]
  x = np.copy(x0)
  errors = []

  for it in range(max_iter):
    x_new = np.zeros(n)
    for i in range(n):
      x_new[i] = b[i] - np.dot(A[i, :i], x[:i]) - np.dot(A[i, i+1:], x[i+1:])
      x_new[i] /= A[i, i]
  error = np.linalg.norm(x_new - x, np.inf)
  errors.append(error)
  if error < tol:
    print(f"O método de Gauss-Seidel convergiu em {it+1} iterações.")
    return x_new, errors
  x = np.copy(x_new)

  raise ValueError("O método de Jacobi não convergiu.")
# Exemplo de uso
A = np.array([[8, 1, 1 ,-1],
[-2, 12, -1, 0],
[2, 0, 16, 2],
[0, 1, 2, -20]])
b = np.array([18, -7, 54, -14])
x0 = np.zeros_like(b)
x, errors = jacobi(A, b, x0)
print("Solução encontrada:")
print("x =", x)
# Realiza a substituição para obter os valores de b
b_calculado = np.dot(A, x)
# Determina o erro relativo para cada valor de b
erro_relativo = np.abs(b - b_calculado) / np.abs(b)
# Formatação dos resultados com 5 casas decimais
x_formatado = [f"{valor:.15f}" for valor in x]
b_calculado_formatado = [f"{valor:.15f}" for valor in b_calculado]
erro_relativo_formatado = [f"{valor:.15f}" for valor in erro_relativo]
print("Valores de b no sistema:", b)
print("Valores de b calculados:", b_calculado_formatado)
print("Erro relativo:", erro_relativo_formatado)
plt.plot(errors)
plt.xlabel('Número de iterações')
plt.ylabel('Erro')
plt.title('Convergência do Método de Jacobi')
plt.show()

import numpy as np

def check_convergence_sassenfeld(A):
  n = A.shape[0]
  betas = np.zeros(n)

  for i in range(n):
    # Calcula a soma dos elementos fora da diagonal (valores absolutos)
    beta_sum = np.sum(np.abs(A[i,:i])) + np.sum(np.abs(A[i,i+1:]))
    # Calcula o valor de beta para a linha i
    betas[i] = beta_sum / np.abs(A[i,i])
  # Obtém o valor máximo de beta
  beta_max = np.max(betas)
  # Verifica a convergência de acordo com o critério de Sassenfeld
  if beta_max < 1:
    return True
  return False

def check_convergence_lines(A):
  n = A.shape[0]
  for i in range(n):
    # Calcula a soma dos elementos da linha i (exceto o elemento da diagonal)
    row_sum = np.sum(np.abs(A[i,:])) - np.abs(A[i,i])
    # Verifica se a soma é maior ou igual ao valor absoluto do elemento da diagonal
    if row_sum >= np.abs(A[i,i]):
      return False
    return True

def check_system_convergence(A):
  # Verifica a convergência de acordo com o critério de Sassenfeld
  converges_sassenfeld = check_convergence_sassenfeld(A)
  # Verifica a convergência de acordo com o critério das Linhas
  converges_lines = check_convergence_lines(A)
  return converges_sassenfeld, converges_lines
  # Sistema de exemplo (pode ser substituído por qualquer matriz)
A = np.array([[8, 1, 1, -1],
[-2, 12, -1, 0],
[2, 0, 16, 2],
[0, 1, 2, -20]])
# Verificação de convergência
converges_sassenfeld, converges_lines = check_system_convergence(A)
# Impressão dos resultados
if converges_sassenfeld:
  print("O sistema converge de acordo com o critério de Sassenfeld.")
else:
  print("O sistema não converge de acordo com o critério de Sassenfeld.")
if converges_lines:
  print("O sistema converge de acordo com o critério das Linhas.")
else:
  print("O sistema não converge de acordo com o critério das Linhas.")

import numpy as np
from numpy import linalg

def jacobi(A,b,x0,tol,N):
  #monte matrizes e vetores
  A = A.astype("double")
  b = b.astype("double")
  x0 = x0.astype("double")

  n = np.shape(A)[0]
  x = np.zeros(n)
  it = 100
  #iteracoes
  while (it < N):
    it = it+1
    #iteracao
    for i in np.arange(n):
      x[i] = b[i]
      for j in np.concatenate((np.arange(0,i),np.arange(i+1,n))):
        x[i] -= A[i,j]*x0[j]
      x[i] /= A[i,i]
    #tolerancia
    if (np.linalg.norm(x-x0,np.inf) < tol):
      return x
    #nova iteracao
    x0 = np.copy(x)
  raise NameError("Numero Maximo de Iteracoes Excedido!")

A=np.array([[4, 2, 1], [1, 5, -1], [1, 2, 8]]);
b=np.array([[14], [10], [20]]);
x0=np.array([[2], [1], [0.5]]);
jacobi(A,b,x0,0.0001,20)

import numpy as np
import matplotlib.pyplot as plt

def gauss_seidel(A, b, x0, tol=1e-6, max_iter=1000):
  n = A.shape[0]
  x = np.copy(x0)
  errors = []

  for it in range(max_iter):
    x_new = np.zeros(n)
    for i in range(n):
      x_new[i] = b[i] - np.dot(A[i, :i], x_new[:i]) - np.dot(A[i, i+1:],x[i+1:])
      x_new[i] /= A[i, i]
    error = np.linalg.norm(x_new - x, np.inf)
    errors.append(error)
    if error < tol:
      print(f"O método de Gauss-Seidel convergiu em {it+1} iterações.")
      return x_new, errors
    x = np.copy(x_new)

  raise ValueError("O método de Gauss-Seidel não convergiu.")

# Exemplo de uso
A = np.array([[6, -3, -3, 0, 0],
[-3, 6, 0, -3, 0],
[-3, 0, 6, -1, -2],
[0, -3, -1, 5, 0],
[0, 0, -2, 0, 3]])
b = np.array([0, 6, 0, 2, 3])
x0 = np.zeros_like(b)
x, errors = gauss_seidel(A, b, x0)
print("Solução encontrada:")
print("x =", x)
# Realiza a substituição para obter os valores de b
b_calculado = np.dot(A, x)
# Determina o erro relativo para cada valor de b
erro_relativo = np.abs(b - b_calculado) / np.abs(b)
# Formatação dos resultados com 5 casas decimais
x_formatado = [f"{valor:.15f}" for valor in x]
b_calculado_formatado = [f"{valor:.15f}" for valor in b_calculado]
erro_relativo_formatado = [f"{valor:.15f}" for valor in erro_relativo]
print("Valores de b no sistema:", b)
print("Valores de b calculados:", b_calculado_formatado)
print("Erro relativo:", erro_relativo_formatado)
plt.plot(errors)
plt.xlabel('Número de iterações')
plt.ylabel('Erro')
plt.title('Convergência do Método de Gauss-Seidel')
plt.show()

def gauss_seidel(A, b, tol, max):
  x = np.zeros_like(b, dtype=np.double)
  #iteracoes
  for k in range(max):
    x_old = x.copy()
    for i in range(A.shape[0]):
      x[i] = (b[i] - np.dot(A[i,:i], x[:i]) - np.dot(A[i,(i+1):],x_old[(i+1):])) / A[i ,i]
  #tolerancia
    if np.linalg.norm(x - x_old, ord=np.inf) / np.linalg.norm(x, ord=np.inf) < tol:
      break
  return x

A=np.array([[6, -3, -3, 0, 0], [-3, 6, 0, -3, 0], [-3, 0, 6, -1, -2],\
            [0, -3, -1, 5, 0], [0, 0, -2, 0, 3]]);
b=np.array([[0], [6], [0], [2], [3]]);
x0=np.array([[0], [0], [0], [0], [0]]);
gauss_seidel(A,b,0.0001,20)

#impreciso demais aparentemente

import numpy as np
import matplotlib.pyplot as plt

def runge_kutta(V, R, C, dt, t_end):
    # Inicialização
    t = np.arange(0, t_end, dt)
    n = len(t)
    q = np.zeros(n)
    q[0] = 0  # Condição inicial: carga inicial do capacitor

    # Função que define a derivada dq/dt
    def derivative(q):
        return V / R - q / (R * C)

    # Método de Runge-Kutta de 4ª ordem
    for i in range(n-1):
        k1 = dt * derivative(q[i])
        k2 = dt * derivative(q[i] + k1/2)
        k3 = dt * derivative(q[i] + k2/2)
        k4 = dt * derivative(q[i] + k3)
        q[i+1] = q[i] + (k1 + 2*k2 + 2*k3 + k4) / 6

    return t, q

# Parâmetros do circuito
V = 5  # Tensão da fonte (V)
R = 1000  # Resistência (ohms)
C = 0.0001  # Capacitância (F)

# Configurações da simulação
dt = 0.001  # Passo de tempo (s)
t_end = 0.1  # Tempo total de simulação (s)

# Executa a simulação usando o método de Runge-Kutta
t, q = runge_kutta(V, R, C, dt, t_end)

# Plota o gráfico do carregamento do capacitor
plt.plot(t, q)
plt.xlabel('Tempo (s)')
plt.ylabel('Carga do Capacitor (C)')
plt.title('Carregamento do Capacitor')
plt.grid(True)
plt.show()

import numpy as np

# Dados de tempo acumulado (t) e intensidade de precipitação (i)
t = np.array([6.3, 10.5, 15.8])
i = np.array([10.5, 50.6, 15.2])

# Montar o sistema de equações
A = np.vstack([t**2, t, np.ones_like(t)]).T
B = i

# Resolver o sistema de equações
coefficients = np.linalg.inv(A.T @ A) @ A.T @ B
a, b, c = coefficients

# Calcular o resíduo observado
residual = np.linalg.norm(A @ coefficients - B)

# Determinar a quantidade mínima de casas decimais
min_decimal_places = 0
while residual > 0.001:
    min_decimal_places += 1
    residual = np.linalg.norm(np.round(A @ coefficients, min_decimal_places) - B)

# Imprimir os coeficientes e a quantidade mínima de casas decimais
print("Coeficientes:")
print("a =", a)

# Parâmetros do circuito
R = 4
C = 0.1

# Condições iniciais
Vc = 15  # Tensão no capacitor no tempo t = 0
t = 0    # Tempo inicial

# Parâmetros de iteração
h = 0.1  # Passo de tempo
t_final = 2  # Tempo final

# Lista para armazenar os valores da tensão no capacitor
voltage_values = []

# Iteração utilizando o método de Euler
while t <= t_final:
    voltage_values.append(Vc)
    Vc = Vc - h * Vc / (R * C)  # Descarga do capacitor
    t = t + h

# Resultados
for i, voltage in enumerate(voltage_values):
    print(f"Tensão no capacitor no tempo {i * h}s: {voltage}V")

import numpy as np
import matplotlib.pyplot as plt

def circuito_rc_euler(R, C, Vc_inicial, tempo_inicial, tempo_final, passo_tempo):
    tempo = np.arange(tempo_inicial, tempo_final + passo_tempo, passo_tempo)
    valores_tensao = [Vc_inicial]

    for t in tempo[:-1]:
        dVc_dt = -valores_tensao[-1] / (R * C)
        Vc_proximo = valores_tensao[-1] + passo_tempo * dVc_dt
        valores_tensao.append(Vc_proximo)

    return tempo, valores_tensao

# Parâmetros do circuito
R = 4
C = 0.1

# Condições iniciais
Vc_inicial = 15
tempo_inicial = 0
tempo_final = 2
passo_tempo = 0.2

# Resolver o circuito usando o método de Euler
tempo, valores_tensao = circuito_rc_euler(R, C, Vc_inicial, tempo_inicial, tempo_final, passo_tempo)

# Imprimir lista de valores da tensão no capacitor em função do tempo
for t, Vc in zip(tempo, valores_tensao):
    print(f"Tempo: {t:.2f}s | Tensão no Capacitor: {Vc:.3f}V")

# Plotar os resultados
plt.plot(tempo, valores_tensao, '*-')
plt.xlabel('Tempo')
plt.ylabel('Tensão')
plt.title('Circuito RC - Método de Euler')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def f(t, Vc):
    R = 4
    C = 0.1
    return -Vc / (R*C)

def runge_kutta(h, t0, Vc0, n):
    t_values = [t0]
    Vc_values = [Vc0]

    for i in range(n):
        t = t_values[-1]
        Vc = Vc_values[-1]

        k1 = f(t, Vc)
        k2 = f(t + h/2, Vc + h/2 * k1)
        k3 = f(t + h/2, Vc + h/2 * k2)
        k4 = f(t + h, Vc + h * k3)

        t_next = t + h
        Vc_next = Vc + h/6 * (k1 + 2*k2 + 2*k3 + k4)

        t_values.append(t_next)
        Vc_values.append(Vc_next)

    return t_values, Vc_values

# Parâmetros
t0 = 0
Vc0 = 15
h = 0.2
n = 10

# Resolução do circuito
t_values, Vc_values = runge_kutta(h, t0, Vc0, n)

# Plot do gráfico
plt.plot(t_values, Vc_values, 'o-')
plt.xlabel('Tempo')
plt.ylabel('Tensão no Capacitor')
plt.title('Circuito RC - Método de Runge-Kutta de 4ª Ordem')
plt.grid(True)
plt.show()

# Impressão dos valores
for t, Vc in zip(t_values, Vc_values):
    print(f"Tempo: {t:.1f}s, Tensão no Capacitor: {Vc:.3f}V")

# Instalando bibliotecas
import numpy as np
import matplotlib.pyplot as plt
# cria dominio com valores de t
t=np.arange(0,2,0.01)
# define y(t)
y=15*np.exp(-2.5*t)
# plotando o grafico
plt.plot(t,y,color="orange",linewidth=2.0,label='v_c = 15e^(-t/RC)')
# plotando título do grafico e dos eixos x e y
plt.xlabel("tempo (s)", color="green")
plt.ylabel("Tensão (V)", color="purple")
# plotando linhas de grade
plt.legend(loc='upper right')
plt.grid()
plt.show()