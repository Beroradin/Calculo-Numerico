# -*- coding: utf-8 -*-
"""EstudoCalculoNumerico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14aIMyXoDkJJTGE4k5UabN_J1OcBjx94F
"""

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  return np.cos(x)-np.sqrt(x)
xi = 0
xs = 1
tol = 0.0001
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi+xs)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif f(xi)*f(xr)>0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi+xs)/2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo) / abs(x_antigo),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da Bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  return x**3 - 5*(x**2)+ 8*x - 4
xi = 1
xs = 2.3
tol = 0.0001
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi+xs)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif f(xi)*f(xr)>0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi+xs)/2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo) / abs(x_antigo),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da Bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  return 100*np.cos(x)-(50*x)
xi = 1
xs = 2.3
tol = 0.0001
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi+xs)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif f(xi)*f(xr)>0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi+xs)/2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo) / abs(x_antigo),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da Bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  return (x**3)-x-1
xi = 1
xs = 2
tol = 0.005
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi+xs)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif f(xi)*f(xr)>0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi+xs)/2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo) / abs(x_antigo),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da Bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return round(5*np.sin(x**2)-np.exp(x/10), 2)
# gerar sequência de valores de x
x = np.linspace(-1, 10, 20)
# calcular os valores de f(x) para a sequência de x
fx = [f(xi) for xi in x]
# criar tabela de valores de x e f(x)
tabela = []
for xi, fxi in zip(x, fx):
  tabela.append([xi, fxi])
# imprimir tabela
print("x | f(x)")
print("-----|---------")
for linha in tabela:
  print("{:.2f} | {:.2f}".format(linha[0], linha[1]))
# plotar o gráfico da função
plt.plot(x, fx)
plt.title('Gráfico da função f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def f(x):
  return (x**3)-x-1
xi = 1
xs = 2
tol = 0.005
fxi = f(xi)
fxs = f(xs)
xr = ((fxs*xi)-(fxi*xs))/(fxs-fxi)
fxr = f(xr)
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while abs(fxr) > tol:
  contador += 1
  if fxr == 0:
    break
  elif fxi*fxr < 0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  xr_antigo = xr
  xr = ((fxs*xi)-(fxi*xs))/(fxs-fxi)
  fxr = f(xr)
  erro_rel = round(abs(xr - xr_antigo)/abs(xr), 4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da falsa posição’ é:%.5f"% root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
print("A quantidade de iterações foi:", contador)
# Plotando gráfico
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals, color="orange", linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--', linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Falsa Posição')
# plotando a função no mesmo gráfico
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

def f(x):
  return x**3 - 1
def g(x):
  return x
x0 = 1.3
tol = 0.005
max_iter = 100
fig, ax = plt.subplots(figsize=(8,6))
x = np.linspace(0,1.5, 1000) #Corrigir conforme o valor de X0
y = x
ax.plot(x, y, 'b-', label='y=x')
ax.plot(x, g(x), 'g-', label='g(x)')
ax.plot(x, f(x), 'r-', label='f(x)')
ax.plot([x0, x0], [0, g(x0)], 'k--', label='x0',linewidth=0.8)
ax.plot(x0, 0, 'bo', label='x0')
xs = [x0]
contador = 0
erro_rel = tol + 1
while erro_rel > tol or contador < max_iter:
  x = g(x0)
  xs.append(x)
  erro_rel = abs((xs[-1]-xs[-2])/xs[-1])
  ax.plot(xs[-1], 0, 'mo', markersize=4,label='x{}'.format(contador+1))
  ax.plot([x0, x], [g(x0), x], 'm--')
  ax.plot([x, x], [x, g(x)], 'm--')
  ax.plot([x, x], [0, g(x)], 'k--',linewidth=0.5)
  x0 = x
  contador += 1
if contador == max_iter:
  print("O método do ponto fixo não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o método do ponto fixo é:", xs[-1])
  print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
  print("A quantidade de iterações foi:", contador)
ax.plot(xs[-1], g(xs[-1]), 'go', markersize=4, label='intercessão')
ax.plot(x0, f(x0), 'ro', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.8)
ax.legend(loc='upper right', fontsize=6)
plt.xlabel('x', fontsize=14)
plt.ylabel('f(x)', fontsize=14)
plt.title('Identifique o método', fontsize=16)
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return (x**3)-x-1
def df(x):
  return 3*(x**2)-1
x0 = 1
tol = 0.005
max_iter = 100
fig, ax = plt.subplots()
x = np.linspace(0.5, 1.5, 1000) #Corrigir conforme o valor de X0
y = f(x)
ax.plot(x, y, label='f(x)')
contador = 0
xs = []
erro_rel = tol + 1
while abs(erro_rel) > tol and contador < max_iter:
  fx = f(x0)
  dfx = df(x0)
  if dfx == 0:
    break
  x = x0 - (fx/dfx)
  xs.append(x)
  if len(xs) > 1:
    erro_rel = abs((xs[-1]-xs[-2])/xs[-1])
  ax.plot([x0, x], [fx, 0], 'm--',linewidth=0.8, label='Tangente')
  ax.plot(x0, fx, 'mo', markersize=4, label='x{}'.format(contador+1))
  x0 = x
  contador += 1
if contador == max_iter:
  print("O Identifique o método não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o método de Newton-Raphson é:", xs[-1])
  print("O valor do erro relativo final que definiu a parada é:", round(erro_rel*100, 3), "%")
  print("A quantidade de iterações foi:", contador)
ax.plot(x0, f(x0), 'ro', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
ax.legend(fontsize = 8)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método de Newton-Raphson')
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return (x**3)-x-1
xi = 1
xs = 2
tol = 0.005
max_iter = 100
fig, ax = plt.subplots()
x = np.linspace(1,2, 1000) #Corrigir conforme o valor de xi e xs
y = f(x)
ax.plot(x, y, label='f(x)')
contador = 0
xr = []
erro_rel = tol + 1
while erro_rel > tol and contador < max_iter:
  fxi = f(xi)
  fxs = f(xs)
  x = (fxs*xi - fxi*xs)/(fxs - fxi)
  xr.append(x)
  if contador > 1:
    erro_rel = abs((xr[-1]- xr[-2])/xr[-1])
  ax.plot([xi, xs], [f(xi), f(xs)], 'm--',linewidth=0.6, label='Secante')
  ax.plot(x, f(x), 'mo', markersize=3.5, label='x{}'.format(contador+1))
  xi = xs
  xs = x
  contador += 1
# impressão dos resultados
if contador == max_iter:
  print("O Identifique o método não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o método da secante é:", xr[-1])
  print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
  print("A quantidade de iterações foi:", contador)
ax.plot(xr[-1], f(xr[-1]),'ro', markersize=4, label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
ax.legend(fontsize = 8)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Secante')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  e = 0.00006
  D = 72.5
  Re = 4.7e5
  return -2*np.log((e/D/3.7)+(2.51/Re*np.sqrt(x)))-1/np.sqrt(x)
  #x = f
xi = 0.1
xs = 0.6
tol = 0.005
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi+xs)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif f(xi)*f(xr)>0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi+xs)/2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo) / abs(x_antigo),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da Bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  R = 10000
  i = (10**(-12))
  q = 1.6*(10**(-19))
  k = 1.38*(10**(-23))
  T = 300
  V = -30
  return R*(i*(np.exp((q*x)/(k*T))-1))+x -V
xi = -40 # limite inferior do intervalo
xs = 1 # limite superior do intervalo
tol = 0.005
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi + xs) / 2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif (fxi)*(fxr)>0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi + xs) / 2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo) / abs(xr),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função,segundo o método da bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

def f(x):
  return x
def g(x):
  return np.exp(x) - 2
x0 = -1.8
tol = 0.05
max_iter = 100
fig, ax = plt.subplots(figsize=(8,6))
x = np.linspace(-2,-1.6, 1000) #Corrigir conforme o valor de X0
y = x
ax.plot(x, y, 'b-', label='y=x')
ax.plot(x, g(x), 'g-', label='g(x)')
ax.plot(x, f(x), 'r-', label='f(x)')
ax.plot([x0, x0], [0, g(x0)], 'k--', label='x0',linewidth=0.8)
ax.plot(x0, 0, 'bo', label='x0')
xs = [x0]
contador = 0
erro_rel = tol + 1
while erro_rel > tol and contador < max_iter:
  x = g(x0)
  xs.append(x)
  erro_rel = abs((xs[-1]-xs[-2])/xs[-1])
  ax.plot(xs[-1], 0, 'mo', markersize=4,label='x{}'.format(contador+1))
  ax.plot([x0, x], [g(x0), x], 'm--')
  ax.plot([x, x], [x, g(x)], 'm--')
  ax.plot([x, x], [0, g(x)], 'k--',linewidth=0.5)
  x0 = x
  contador += 1
if contador == max_iter:
  print("O Método do ponto fixo não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o Método do ponto fixo é:", xs[-1])
  print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
  print("A quantidade de iterações foi:", contador)
ax.plot(xs[-1], g(xs[-1]), 'go', markersize=4, label='intercessão')
ax.plot(x0, f(x0), 'ro', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.8)
ax.legend(loc='upper right', fontsize=6)
plt.xlabel('x', fontsize=14)
plt.ylabel('f(x)', fontsize=14)
plt.title(' Método do ponto fixo ', fontsize=16)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  u = 2000
  m = 150000
  return u*np.log(m/(m-2700*x))-(9.81*x)-750
xi = 10 # limite inferior do intervalo
xs = 50 # limite superior do intervalo
tol = 0.005
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi + xs) / 2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif (fxi)*(fxr)>0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi + xs) / 2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo) / abs(xr),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função,segundo o método da bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  e = 0.00006
  D = 0.725
  R = 4.7*(10**5)
  return -2*np.log10((e/D)/3.7 + 2.51/(R*np.sqrt(x)))-(1/np.sqrt(x))
xi = 0.01 # limite inferior do intervalo
xs = 0.03 # limite superior do intervalo
tol = 0.005
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi + xs) / 2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif (fxi)*(fxr)>0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi + xs) / 2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo) / abs(xr),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função,segundo o método da bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()