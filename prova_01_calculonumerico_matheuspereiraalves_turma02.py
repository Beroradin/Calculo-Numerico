# -*- coding: utf-8 -*-
"""Prova_01_CalculoNumerico_MatheusPereiraAlves_Turma02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x6a7kDb2uzYXYlH0aQTZDPH0j5goYLuE

Questao 2

V = (pi * x**2(3r-x))/3, onde r = 1 e o V = 0.75 e tol = 0.005 e x = h
"""

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  r = 1
  V = 0.75
  return round((np.pi*(x**2)*(3*r-x)/3 - V), 2)
# gerar sequência de valores de x
x = np.linspace(-5, 10, 20)
# calcular os valores de f(x) para a sequência de x
fx = [f(xi) for xi in x]
# criar tabela de valores de x e f(x)
tabela = []
for xi, fxi in zip(x, fx):
  tabela.append([xi, fxi])
# imprimir tabela
print("x | f(x)")
print("-----|---------")
for linha in tabela:
  print("{:.2f} | {:.2f}".format(linha[0], linha[1]))
# plotar o gráfico da função
plt.plot(x, fx)
plt.title('Gráfico da função f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  r = 1
  V = 0.75
  return (np.pi*(x**2)*(3*r-x))/3 - V
xi = 0.5
xs = 1.3
tol = 0.005
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi+xs)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif fxi*fxr > 0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi+xs)/2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo)/abs(xr),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  r = 1
  V = 0.75
  return (np.pi*(x**2)*(3*r-x))/3 - V
xi = 2.8
xs = 3.5
tol = 0.005
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi+xs)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif fxi*fxr > 0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi+xs)/2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo)/abs(xr),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

"""Questao 3

f(x) = x^2 + 6*x -1

raiz = [-0.26 , 0.53]
"""

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return round((x**2)+6*x-1, 2)
# gerar sequência de valores de x
x = np.linspace(-5, 10, 20)
# calcular os valores de f(x) para a sequência de x
fx = [f(xi) for xi in x]
# criar tabela de valores de x e f(x)
tabela = []
for xi, fxi in zip(x, fx):
  tabela.append([xi, fxi])
# imprimir tabela
print("x | f(x)")
print("-----|---------")
for linha in tabela:
  print("{:.2f} | {:.2f}".format(linha[0], linha[1]))
# plotar o gráfico da função
plt.plot(x, fx)
plt.title('Gráfico da função f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  return (x**2)+6*x-1
xi = -0.26
xs = 0.53
tol = 0.005
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi+xs)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif fxi*fxr > 0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi+xs)/2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo)/abs(xr),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  return (x**2)+6*x-1
xi = -0.26
xs = 0.53
tol = 0.005
fxi = f(xi)
fxs = f(xs)
xr = (xi*fxs - xs*fxi)/(fxs - fxi)
fxr = f(xr)
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif fxi * fxr > 0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  xr_antigo = xr
  xr = (xi*fxs - xs*fxi)/(fxs - fxi)
  fxr = f(xr)
  erro_rel = round(abs(xr - xr_antigo)/abs(xr), 4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o Método da FalsaPosição é:%.5f"% root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals, color="orange", linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--', linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Falsa Posição')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return (x**2)+6*x-1
def g(x):
  return 1/(x+6)
x0 = 0.16
tol = 0.005
max_iter = 100
fig, ax = plt.subplots(figsize=(8,6))
x = np.linspace(0.1,0.2, 1000) #Corrigir conforme o valor de X0
y = x
ax.plot(x, y, 'b-', label='y=x')
ax.plot(x, g(x), 'g-', label='g(x)')
ax.plot(x, f(x), 'r-', label='f(x)')
ax.plot([x0, x0], [0, g(x0)], 'k--', label='x0',linewidth=0.8)
ax.plot(x0, 0, 'bo', label='x0')
xs = [x0]
contador = 0
erro_rel = tol + 1
while erro_rel > tol and contador < max_iter:
  x = g(x0)
  xs.append(x)
  erro_rel = abs((xs[-1]-xs[-2])/xs[-1])
  ax.plot(xs[-1], 0, 'mo', markersize=4,label='x{}'.format(contador+1))
  ax.plot([x0, x], [g(x0), x], 'm--')
  ax.plot([x, x], [x, g(x)], 'm--')
  ax.plot([x, x], [0, g(x)], 'k--',linewidth=0.5)
  x0 = x
  contador += 1
if contador == max_iter:
  print("O Método do ponto fixo não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o Método do ponto fixo é:", xs[-1])
  print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
  print("A quantidade de iterações foi:", contador)
ax.plot(xs[-1], g(xs[-1]), 'go', markersize=4, label='intercessão')
ax.plot(x0, f(x0), 'ro', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.8)
ax.legend(loc='upper right', fontsize=6)
plt.xlabel('x', fontsize=14)
plt.ylabel('f(x)', fontsize=14)
plt.title(' Método do ponto fixo ', fontsize=16)
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return (x**2)+6*x-1
def df(x):
  return (2*x)+6
x0 = 1.6
tol = 0.005
max_iter = 100
fig, ax = plt.subplots()
x = np.linspace(1,2, 1000) #Corrigir conforme o valor de X0
y = f(x)
ax.plot(x, y, label='f(x)')
contador = 0
xs = []
erro_rel = tol + 1
while erro_rel > tol and contador < max_iter:
  fx = f(x0)
  dfx = df(x0)
  if dfx == 0:
    break
  x = x0 - (fx/dfx)
  xs.append(x)
  if len(xs) > 1:
    erro_rel = abs((xs[-1]-xs[-2])/xs[-1])
  ax.plot([x0, x], [fx, 0], 'm--',linewidth=0.8, label='Tangente')
  ax.plot(x0, fx, 'mo', markersize=4, label='x{}'.format(contador+1))
  x0 = x
  contador += 1
if contador == max_iter:
  print("O Método de Newton-Raphson não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o Método de NewtonRaphson é:", xs[-1])
  print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
  print("A quantidade de iterações foi:", contador)
ax.plot(x0, f(x0), 'ro', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
ax.legend(fontsize = 8)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método de Newton-Raphson')
plt.show()

"""Questao 4

y = 7(2-0.9^t)

existe um y = 10

tol = 0.005

(a^x)' = a^x * ln(a)
"""

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return round(7*(2-0.9**x)-10, 2)
# gerar sequência de valores de x
x = np.linspace(-5, 10, 20)
# calcular os valores de f(x) para a sequência de x
fx = [f(xi) for xi in x]
# criar tabela de valores de x e f(x)
tabela = []
for xi, fxi in zip(x, fx):
  tabela.append([xi, fxi])
# imprimir tabela
print("x | f(x)")
print("-----|---------")
for linha in tabela:
  print("{:.2f} | {:.2f}".format(linha[0], linha[1]))
# plotar o gráfico da função
plt.plot(x, fx)
plt.title('Gráfico da função f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return 7*(2-0.9**x)-10
def df(x):
  return (7*(2-((0.9**x) * np.log(0.9))))-10
x0 = 5.6
tol = 0.005
max_iter = 100
fig, ax = plt.subplots()
x = np.linspace(5.2,6, 1000) #Corrigir conforme o valor de X0
y = f(x)
ax.plot(x, y, label='f(x)')
contador = 0
xs = []
erro_rel = tol + 1
while erro_rel > tol and contador < max_iter:
  fx = f(x0)
  dfx = df(x0)
  if dfx == 0:
    break
  x = x0 - (fx/dfx)
  xs.append(x)
  if len(xs) > 1:
    erro_rel = abs((xs[-1]-xs[-2])/xs[-1])
  ax.plot([x0, x], [fx, 0], 'm--',linewidth=0.8, label='Tangente')
  ax.plot(x0, fx, 'mo', markersize=4, label='x{}'.format(contador+1))
  x0 = x
  contador += 1
if contador == max_iter:
  print("O Método de Newton-Raphson não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o Método de NewtonRaphson é:", xs[-1])
  print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
  print("A quantidade de iterações foi:", contador)
ax.plot(x0, f(x0), 'ro', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
ax.legend(fontsize = 8)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método de Newton-Raphson')
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  return 7*(2-0.9**x)-10
xi = 5.2
xs = 6
tol = 0.005
max_iter = 100
fig, ax = plt.subplots()
x = np.linspace(5.2,6, 1000) #Corrigir conforme o valor de xi e xs
y = f(x)
ax.plot(x, y, label='f(x)')
contador = 0
xr = []
erro_rel = tol + 1
while erro_rel > tol and contador < max_iter:
  fxi = f(xi)
  fxs = f(xs)
  x = (xi*fxs - xs*fxi)/(fxs - fxi)
  xr.append(x)
  if contador > 1:
    erro_rel = abs((xr[-1]-xr[-2])/xr[-1])
  ax.plot([xi, xs], [f(xi), f(xs)], 'm--',linewidth=0.6, label='Secante')
  ax.plot(x, f(x), 'mo', markersize=3.5, label='x{}'.format(contador+1))
  xi = xs
  xs = x
  contador += 1
# impressão dos resultados
if contador == max_iter:
  print("O Método da Secante não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o método da Secante é:", xr[-1])
  print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
  print("A quantidade de iterações foi:", contador)
ax.plot(xr[-1], f(xr[-1]),'ro', markersize=4, label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
ax.legend(fontsize = 8)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title(' Método da Secante')
plt.show()

"""Questao 5

P(x) = 25x^2 + ln(x) , onde x = d

Qual o valor de x para que P = 1,5e-4

(ln(a))' = 1/a e se ln(x) -> x > 0
"""

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  P = 1.5 * (10**-4)
  return round(25*(x**2) + np.log(x) - P, 2)
# gerar sequência de valores de x
x = np.linspace(0.1, 10, 20)
# calcular os valores de f(x) para a sequência de x
fx = [f(xi) for xi in x]
# criar tabela de valores de x e f(x)
tabela = []
for xi, fxi in zip(x, fx):
  tabela.append([xi, fxi])
# imprimir tabela
print("x | f(x)")
print("-----|---------")
for linha in tabela:
  print("{:.2f} | {:.2f}".format(linha[0], linha[1]))
# plotar o gráfico da função
plt.plot(x, fx)
plt.title('Gráfico da função f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
def f(x):
  P = 1.5 * (10**-4)
  return 25*(x**2) + np.log(x) - P
xi = 0.1
xs = 0.6
tol = 0.005
# Implementação do método
fxi = f(xi)
fxs = f(xs)
xr = (xi+xs)/2
fxr = f(xr)
erro_rel = 1
x_vals = [xi, xs, xr]
y_vals = [fxi, fxs, fxr]
contador = 0
while erro_rel > tol:
  contador += 1
  if fxr == 0:
    break
  elif fxi*fxr > 0:
    xi = xr
    fxi = fxr
  else:
    xs = xr
    fxs = fxr
  x_antigo = xr
  xr = (xi+xs)/2
  fxr = f(xr)
  erro_rel =round(abs(xr - x_antigo)/abs(xr),4)
  x_vals.append(xr)
  y_vals.append(fxr)
# Obtendo resultados
root = xr
print("O valor aproximado da raiz da função, segundo o método da bisseção é:",root)
print("O valor do erro relativo final que definiu a parada é:", erro_rel*100,"%")
print("A quantidade de iterações foi:", contador)
plt.plot(x_vals, y_vals, '|')
plt.plot(x_vals, y_vals,color="orange",linewidth=0.5)
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da bisseção')
x = np.linspace(x_vals[0], x_vals[1], 20)
plt.plot(x, f(x), color="blue", label='f(x)', linewidth=0.8)
plt.show()

import matplotlib.pyplot as plt
import numpy as np
def f(x):
  P = 1.5 * (10**-4)
  return 25*(x**2) + np.log(x) - P
def df(x):
  return 50*x + (1/x)
x0 = 0.2
tol = 0.005
max_iter = 100
fig, ax = plt.subplots()
x = np.linspace(0.1,0.6, 1000) #Corrigir conforme o valor de X0
y = f(x)
ax.plot(x, y, label='f(x)')
contador = 0
xs = []
erro_rel = tol + 1
while erro_rel > tol and contador < max_iter:
  fx = f(x0)
  dfx = df(x0)
  if dfx == 0:
    break
  x = x0 - (fx/dfx)
  xs.append(x)
  if len(xs) > 1:
    erro_rel = abs((xs[-1]-xs[-2])/xs[-1])
  ax.plot([x0, x], [fx, 0], 'm--',linewidth=0.8, label='Tangente')
  ax.plot(x0, fx, 'mo', markersize=4, label='x{}'.format(contador+1))
  x0 = x
  contador += 1
if contador == max_iter:
  print("O Método de Newton-Raphson não convergiu após %d iterações."%contador)
else:
  print("O valor aproximado da raiz da função, segundo o Método de NewtonRaphson é:", xs[-1])
  print("O valor do erro relativo final que definiu a parada é:", erro_rel*100, "%")
  print("A quantidade de iterações foi:", contador)
ax.plot(x0, f(x0), 'ro', label='Raiz')
plt.axhline(y=0, color='black', linestyle='--',linewidth=0.5)
ax.legend(fontsize = 8)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método de Newton-Raphson')
plt.show()